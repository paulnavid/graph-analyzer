package graphanalyzer.controller.routines;

import java.awt.Color;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Set;
import java.util.TreeMap;

import graphanalyzer.model.algorithms.StronglyConnectedComponentsAlgorithm;
import graphanalyzer.model.graph.DirectedGraph;
import graphanalyzer.model.graph.Vertex;
import graphanalyzer.view.MainGUI;

/**
 * Routine for a algorithm that computes the Strongly Connected Components of a
 * directed graph.
 * <p>
 * Implementation of the interface AlgorithmRoutine that is mainly based around
 * a "state machine." The state machine is implemented by a simple enum
 * {@link STATE}. It has three values:
 * <ol>
 * <li>FIRST: Displays the first depth first search of the algorithm.</li>
 * <li>TRANSPOSE: Displays the transposed graph.</li>
 * <li>SECOND: Displays the second depth first search of the algorithm.</li>
 * </ol>
 * 
 * @see AlgorithmRoutine
 * 
 * @author paulehler
 *
 */
public class StronglyConnectedComponentsRoutine implements AlgorithmRoutine {

	/**
	 * Autogenerated unique serial version identifier
	 * 
	 * @see Serializable#serialVersionUID
	 */
	private static final long serialVersionUID = -460816047146222742L;

	/**
	 * Default vertex color the graph gets filled with. It means the vertex is
	 * neither discovered, nor finished.
	 */
	private static final Color DEFAULT_VERTEX_FILL_COLOR = Color.WHITE;

	/**
	 * Vertex color to show it is discovered.
	 */
	private static final Color DISCOVERED_VERTEX_COLOR = new Color(0x4088C7);
	// private static final Color DISCOVERED_VERTEX_COLOR = new Color(0x2E8CB9); // Alternative

	/**
	 * Vertex color to show it is finished
	 */
	private static final Color FINISHED_VERTEX_COLOR = new Color(0x34B362);
	// private static final Color FINISHED_VERTEX_COLOR = new Color(0x8DA470); // Alternative

	/**
	 * Very simple version of something like a "state machine".
	 * 
	 * @see StronglyConnectedComponentsRoutine
	 */
	private enum STATE {
		FIRST, TRANSPOSE, SECOND;
	}

	/**
	 * Current state of the routine.
	 * 
	 * @see STATE
	 */
	private STATE state;

	/**
	 * Instance of the GUI that is used to display all information.
	 */
	private transient MainGUI gui;

	/**
	 * Graph the algorithm should be used with.
	 */
	private DirectedGraph graph;

	/**
	 * Instance of the actual algorithm.
	 * 
	 * @see StronglyConnectedComponentsAlgorithm
	 */
	private StronglyConnectedComponentsAlgorithm alg;

	/**
	 * Protocol list of the first depth first search of the algorithm
	 */
	private ArrayList<Vertex> firstDfsHistory;

	/**
	 * List of strongly connected components of given {@link #graph}
	 * 
	 * @see
	 */
	private List<ArrayList<Vertex>> stronglyConnectedComponents;

	/**
	 * Builder for the content that should be displayed in the secondary panel of
	 * {@link graphanalyzer.view.panels.GraphPanel}
	 */
	private StringBuilder secondaryPanelContent;

	/**
	 * Maps vertices to the amount of "visits" throughout the first depth first
	 * 
	 * @see {@link graphanalyzer.model.algorithms.StronglyConnectedComponentsAlgorithm#getFirsDfsProtocol()}
	 */
	private HashMap<Vertex, Integer> mapVertexToVisitCount;

	/**
	 * List of random colors for strongly connected components to display in graph
	 */
	private ArrayList<Color> colorsForScc;

	/**
	 * Counts the current position of the first DFS
	 */
	private int firstDfsCounter;

	/**
	 * Counts the current position of the outer list of the
	 * {@link #stronglyConnectedComponents}
	 * 
	 * @see {@link graphanalyzer.model.algorithms.StronglyConnectedComponentsAlgorithm#getStronglyConnectedComponents()}
	 */
	private int sccOuterCounter;

	/**
	 * Counts the current position of the outer list of the
	 * {@link #stronglyConnectedComponents}
	 * 
	 * @see {@link graphanalyzer.model.algorithms.StronglyConnectedComponentsAlgorithm#getStronglyConnectedComponents()}
	 */
	private int sccInnerCounter;

	/**
	 * Initializes an instance of the routine to visualize strongly connected
	 * components in a graph.
	 * 
	 * @param graph graph to work with
	 * @param gui   graphical user interface to display the results to
	 */
	public StronglyConnectedComponentsRoutine(DirectedGraph graph, MainGUI gui) {
		this.graph = graph;
		this.gui = gui;

		firstDfsCounter = 0;
		sccInnerCounter = 0;
		sccOuterCounter = 0;

		// Initialize first state
		state = STATE.FIRST;

		// Initialize algorithm and compute results
		alg = new StronglyConnectedComponentsAlgorithm();
		alg.init(graph);
		alg.compute();

		firstDfsHistory = (ArrayList<Vertex>) alg.getFirsDfsProtocol();

		// Initialize map that counts visits of vertices with 0 visits
		mapVertexToVisitCount = new HashMap<>();
		Set<Vertex> vertices = this.graph.getVertices();
		for (Vertex vertex : vertices) {
			mapVertexToVisitCount.put(vertex, 0);
		}

		secondaryPanelContent = new StringBuilder();

		stronglyConnectedComponents = alg.getStronglyConnectedComponents();

		colorsForScc = new ArrayList<>();
		// Compute "random" colors according to the amount of strongly connected
		// components
		float interval = 360f / (stronglyConnectedComponents.size());
		for (float x = 0; x < 360; x += interval) {
			Color c = Color.getHSBColor(x / 360, 0.3f, 0.8f);
			colorsForScc.add(c);
		}

	}

	@Override
	public void nextStep() {

		switch (state) {
		case FIRST:
			gui.updateDescriptionPanel("algorithm.scc.firstdfs.title", "algorithm.scc.firstdfs.content");
			gui.getGraphPanel().shouldDrawTransposed(false);
			drawFirstDfsLegend();
			

			if (firstDfsCounter >= firstDfsHistory.size()) {
				nextState();
				break;
			}

			Vertex currentVertex = firstDfsHistory.get(firstDfsCounter);
			incrementVisitCounter(currentVertex);
			System.err.println(mapVertexToVisitCount);

			if (isDiscovered(currentVertex)) {

				markDiscoveredVertex(currentVertex); // NEW
				System.out.println("Discovered: " + currentVertex);

			} else {

				markFinishedVertex(currentVertex); // NEW
				secondaryPanelContent.insert(0, currentVertex.toString() + "\n");
				gui.updateSecondaryPanel(secondaryPanelContent.toString());
				System.out.println("Finished: " + currentVertex);

			}
			
			firstDfsCounter++;
			
			break;
		case TRANSPOSE:
			gui.updateDescriptionPanel("algorithm.scc.transposegraph.title", "algorithm.scc.transposegraph.content");

			markAllUnvisited(); // NEW
			gui.getGraphPanel().setLegend(null);
			gui.getGraphPanel().shouldDrawTransposed(true);

			nextState();
			break;

		case SECOND:
			gui.updateDescriptionPanel("algorithm.scc.seconddfs.title", "algorithm.scc.seconddfs.content");
			gui.getGraphPanel().shouldDrawTransposed(true);
			drawSccLegend();

			if (sccOuterCounter >= stronglyConnectedComponents.size()) {
				break;
			}

			System.out.println("inner: " + sccInnerCounter + " Outer: " + sccOuterCounter);
			ArrayList<Vertex> scc = stronglyConnectedComponents.get(sccOuterCounter); // Get one scc
			if (sccInnerCounter < scc.size()) {

				Vertex current = scc.get(sccInnerCounter); // Get element of this scc
				System.err.println("Current: " + current);
				gui.getGraphPanel().setVertexColor(current, colorsForScc.get(sccOuterCounter)); // Set colors for
																								// SCC
				secondaryPanelContent.delete(0, secondaryPanelContent.indexOf("\n") + 1); // remove first line
				gui.updateSecondaryPanel(secondaryPanelContent.toString());

			}

			if (sccInnerCounter < scc.size() - 1) {
				// Current SCC not finished yet
				sccInnerCounter++;

			} else if (sccOuterCounter < stronglyConnectedComponents.size() - 1) {
				sccOuterCounter++;
			}

			break;
		default:
			break;
		}

	}

	@Override
	public void previousStep() {

		switch (state) {
		case FIRST:
			gui.updateDescriptionPanel("algorithm.scc.firstdfs.title", "algorithm.scc.firstdfs.content");
			gui.getGraphPanel().shouldDrawTransposed(false);
			drawFirstDfsLegend();

			if (firstDfsCounter <= 0) {
				break;
			}

			firstDfsCounter--;

			Vertex currentVertex = firstDfsHistory.get(firstDfsCounter); // get current vertex

			decrementVisitCounter(currentVertex); // Decrement visit count

			System.err.println(mapVertexToVisitCount);

			if (mapVertexToVisitCount.get(currentVertex) > 0) {

				markDiscoveredVertex(currentVertex);
				// Update secondary Panel
				secondaryPanelContent.delete(0, secondaryPanelContent.indexOf("\n") + 1); // remove first line
				gui.updateSecondaryPanel(secondaryPanelContent.toString());

			} else {

				markUnvisitedVertex(currentVertex);

			}
			break;

		case TRANSPOSE:
			gui.updateDescriptionPanel("algorithm.scc.transposegraph.title", "algorithm.scc.transposegraph.content");
			gui.getGraphPanel().setLegend(null);
			gui.getGraphPanel().shouldDrawTransposed(false);

			markAllFinished();
			previousState();

			break;

		case SECOND:
			gui.updateDescriptionPanel("algorithm.scc.seconddfs.title", "algorithm.scc.seconddfs.content");
			gui.getGraphPanel().shouldDrawTransposed(true);

			System.out.println("inner: " + sccInnerCounter + " Outer: " + sccOuterCounter);
			if (sccOuterCounter >= 0) {

				ArrayList<Vertex> scc = stronglyConnectedComponents.get(sccOuterCounter); // Get current scc

				if (sccInnerCounter >= 0 && sccInnerCounter < scc.size()) {

					Vertex current = scc.get(sccInnerCounter); // Get element of this scc
					System.err.println("Current: " + current);

					markUnvisitedVertex(current);
					secondaryPanelContent.insert(0, current + "\n");
					gui.updateSecondaryPanel(secondaryPanelContent.toString());

				}

				if ((sccInnerCounter - 1) < 0) {
					sccOuterCounter--;
				} else {
					sccInnerCounter--;
				}
				
			} else {
				sccInnerCounter = 0;
				sccOuterCounter = 0;
				previousState();
			}

			break;

		default:
			break;
		}

	}

	/**
	 * Increment the counter of {@link #mapVertexToVisitCount}
	 * 
	 * @param currentVertex vertex
	 */
	private void incrementVisitCounter(Vertex currentVertex) {
		mapVertexToVisitCount.put(currentVertex, mapVertexToVisitCount.get(currentVertex) + 1);
	}

	/**
	 * Decrement the counter of {@link #mapVertexToVisitCount}
	 * 
	 * @param currentVertex vertex
	 */
	private void decrementVisitCounter(Vertex currentVertex) {
		mapVertexToVisitCount.put(currentVertex, mapVertexToVisitCount.get(currentVertex) - 1);
	}

	/**
	 * Set color of specific vertex to default color.
	 * 
	 * @param unvisitedVertex vertex to be modified
	 */
	private void markUnvisitedVertex(Vertex unvisitedVertex) {
		gui.getGraphPanel().setVertexColor(unvisitedVertex, DEFAULT_VERTEX_FILL_COLOR);
	}

	/**
	 * Set color of specific vertex to discovered color.
	 * 
	 * @param discoveredVertex vertex to be modified
	 */
	private void markDiscoveredVertex(Vertex discoveredVertex) {
		gui.getGraphPanel().setVertexColor(discoveredVertex, DISCOVERED_VERTEX_COLOR);
	}

	/**
	 * Set color of specific vertex to finished color.
	 * 
	 * @param finishedVertex vertex to be modified
	 */
	private void markFinishedVertex(Vertex finishedVertex) {
		gui.getGraphPanel().setVertexColor(finishedVertex, FINISHED_VERTEX_COLOR);
	}

	/**
	 * Reset color of all vertices by setting to default color.
	 */
	private void markAllUnvisited() {
		for (Vertex vertex : graph.getVertices()) {
			gui.getGraphPanel().setVertexColor(vertex, DEFAULT_VERTEX_FILL_COLOR);
		}
	}

	/**
	 * Set color of all vertices to finished color.
	 */
	private void markAllFinished() {
		for (Vertex vertex : graph.getVertices()) {
			markFinishedVertex(vertex);
		}
	}

	/**
	 * Call the setLegend method of the GraphPanel with the colors for discovered
	 * and finished vertices.
	 */
	private void drawFirstDfsLegend() {
		HashMap<String, Color> mapColorToName = new HashMap<>();
		mapColorToName.put("Discovered", DISCOVERED_VERTEX_COLOR);
		mapColorToName.put("Finished", FINISHED_VERTEX_COLOR);
		gui.getGraphPanel().setLegend(mapColorToName);
	}

	/**
	 * Call the setLegend method of the GraphPanel with the colors for the strongly
	 * connected components.
	 */
	private void drawSccLegend() {
		TreeMap<String, Color> mapColorToName = new TreeMap<>(Collections.reverseOrder());
		int sccCounter = 1;
		for (Color color : colorsForScc) {
			mapColorToName.put("SCC-" + sccCounter, color);
			sccCounter++;
		}
		gui.getGraphPanel().setLegend(mapColorToName);

	}

	/**
	 * Returns true if the vertex was recently discovered.
	 * 
	 * @param currentVertex vertex to check
	 * @return true if visit count is < 2, else false
	 */
	private boolean isDiscovered(Vertex currentVertex) {
		return mapVertexToVisitCount.get(currentVertex) < 2;
	}

	/**
	 * Perform a change of state to the next state of {@link STATE}.
	 */
	private void nextState() {
		switch (state) {
		case FIRST:
			state = STATE.TRANSPOSE;
			break;
		case TRANSPOSE:
			state = STATE.SECOND;
			break;
		default:
			break;
		}

	}

	/**
	 * Perform a change of state to the previous state of {@link STATE}.
	 */
	private void previousState() {
		switch (state) {
		case TRANSPOSE:
			state = STATE.FIRST;
			break;
		case SECOND:
			state = STATE.TRANSPOSE;
			break;
		default:
			break;
		}

	}

}
