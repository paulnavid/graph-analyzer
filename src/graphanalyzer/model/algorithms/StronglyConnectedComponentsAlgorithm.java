package graphanalyzer.model.algorithms;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;

import graphanalyzer.model.graph.*;

/**
 * Implementation of a graph algorithm that calculates strongly connected
 * components based on two depth-first-searches.
 * <p>
 * This algorithm finds strongly connected components in a given graph. It does
 * so by traversing the graph in a depth first search. Finished vertices get
 * added to a stack. After transposing the graph and unvisiting all vertices a
 * second depth first search is started. But this time the vertices are visited
 * recording to their position in the stack. A depth first search from the top
 * level item of the stack is started and every vertex that has been found on
 * this search is part of the same strongly connected component. The algorithm
 * uses the fact that a strongly connected component of a given graph G is also
 * a strongly connected component in its transpose G(T).
 * 
 * @see <a href=
 *      "https://en.wikipedia.org/wiki/Strongly_connected_component">Strongly
 *      connected component (Wikipedia)</a>
 * 
 * @author Paul Ehler
 *
 */
public class StronglyConnectedComponentsAlgorithm implements Algorithm, Serializable {

	/**
	 * Autogenerated unique serial version identifier
	 * 
	 * @see Serializable#serialVersionUID
	 */
	private static final long serialVersionUID = 3049007391864642836L;

	/**
	 * The graph the algorithm should use to compute its strongly connected
	 * components
	 */
	private DirectedGraph graph;

	/**
	 * The transpose of the given {@link #graph}
	 */
	private DirectedGraph transposedGraph;

	/**
	 * The computed strongly connected components. Every list inside the list
	 * expresses a scc
	 */
	private List<ArrayList<Vertex>> stronglyConnectedComponents;

	/**
	 * A list used to store vertices that have been visited
	 */
	private Set<Vertex> visitedVertices;

	/**
	 * Stack of the finished vertices of the first depth first search
	 */
	private Stack<Vertex> finishedVertices;

	/**
	 * A list of the vertices visited in the first depth first search
	 */
	private LinkedList<Vertex> firstDFS;

	/**
	 * A list of the vertices visited in the second depth first search
	 */
	private LinkedList<Vertex> secondDFS;

	/**
	 * A list that contains the complete DFS path of the first DFS
	 */
	private ArrayList<Vertex> firstDfsProtocol;

	/**
	 * A counter variable that is used to determine the timestamps for
	 * {@link #discoveryTimes} and {@link #finishingTimes}
	 */
	private int time;

	/**
	 * A map that contains every vertex of the graph and its specific discovery time
	 */
	private Map<Vertex, Integer> discoveryTimes;

	/**
	 * A map that contains every vertex of the graph and its specific finishing time
	 */
	private Map<Vertex, Integer> finishingTimes;

	/**
	 * Constructor for a new Strongly Connected Component Algorithm.
	 * 
	 * @param g
	 */
	public StronglyConnectedComponentsAlgorithm() {

		stronglyConnectedComponents = new ArrayList<>();
		visitedVertices = new HashSet<>();
		finishedVertices = new Stack<>();

		firstDfsProtocol = new ArrayList<>();

		firstDFS = new LinkedList<>();
		secondDFS = new LinkedList<>();

		discoveryTimes = new HashMap<>();
		finishingTimes = new HashMap<>();

		time = 0;
	}

	@Override
	public void init(Graph graph) {
		this.graph = (DirectedGraph) graph;
		transposedGraph = this.graph.getTransposedGraph();

	}

	@Override
	public void compute() {
		for (Vertex v : graph.getVertices()) {
			if (!visitedVertices.contains(v)) {
				dfsVisit(graph, v, false, null);
			}
		}

		visitedVertices.clear();

		while (!finishedVertices.empty()) {
			Vertex v = finishedVertices.pop();
			ArrayList<Vertex> scc = new ArrayList<>();
			stronglyConnectedComponents.add(scc);
			if (!visitedVertices.contains(v)) {
				dfsVisit(transposedGraph, v, true, scc);
			}
		}

		// Remove empty lists inside stronglyConnectedComponents due to implementation
		// issues
		stronglyConnectedComponents.removeIf(c -> c.isEmpty());

	}

	/**
	 * This method implements the visit of the depth first search.
	 * <p>
	 * It is implemented so that it can be used for both the first and the second
	 * DFS. Therefore the graph, a boolean that determines whether it is the second
	 * DFS or not and a set that will be filled with sccs gets passed.
	 * 
	 * @param g           the graph to work on
	 * @param v           currently visited vertex
	 * @param isSecondRun whether it is first or second dfs
	 * @param set         a set the sccs get saved to
	 */
	private void dfsVisit(DirectedGraph g, Vertex v, boolean isSecondRun, ArrayList<Vertex> set) {
		visitedVertices.add(v); // Mark v as visited

		if (isSecondRun) {
			set.add(v); // Add vertex to SCC
			secondDFS.add(v);
		} else {
			firstDFS.add(v);
			discoveryTimes.put(v, time);
			firstDfsProtocol.add(v);
			time++;
		}

		for (Vertex vertex : g.getTargetsOfVertex(v)) {
			if (!visitedVertices.contains(vertex)) {
				dfsVisit(g, vertex, isSecondRun, set); // Visit successor vertices if present
			}
		}

		if (!isSecondRun) {
			finishedVertices.push(v); // Add vertex to stack because it is finished
			firstDfsProtocol.add(v);
			finishingTimes.put(v, time);
			time++;
		}

	}

	/**
	 * @return a list of vertices in order of the first dfs
	 */
	public List<Vertex> getFirstDFS() {
		return firstDFS;
	}

	/**
	 * 
	 * @return a list of vertices in order of the second dfs
	 */
	public List<Vertex> getSecondDFS() {
		return secondDFS;
	}

	/**
	 * @return a list of the complete DFS path of the first DFS
	 */
	public List<Vertex> getFirsDfsProtocol() {
		return firstDfsProtocol;
	}

	/**
	 * @return a list containing all strongly connected components in encapsulated
	 *         lists
	 */
	public List<ArrayList<Vertex>> getStronglyConnectedComponents() {
		return stronglyConnectedComponents;
	}

	/**
	 * @return a map that matches all vertices of the graph to their discovery time
	 *         of the first DFS
	 */
	public Map<Vertex, Integer> getDiscoveryTimes() {
		return discoveryTimes;
	}

	/**
	 * @return a map that matches all vertices of the graph to their finishing time
	 *         of the first DFS
	 */
	public Map<Vertex, Integer> getFinishingTimes() {
		return finishingTimes;
	}

}
