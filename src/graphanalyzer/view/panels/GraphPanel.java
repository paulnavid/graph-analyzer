package graphanalyzer.view.panels;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.RenderingHints;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import javax.swing.JPanel;

import graphanalyzer.model.graph.DirectedEdge;
import graphanalyzer.model.graph.Graph;
import graphanalyzer.model.graph.Vertex;
import graphanalyzer.view.MainGUI;
import graphanalyzer.view.components.DirectedEdgeComponent;
import graphanalyzer.view.components.LabeledVertexComponent;

/**
 * Panel that is used to draw the actual graph visualization.
 * <p>
 * As this is a non final product that is still in development the panel only
 * allows draeing of six different vertices. But as the main purpose of the
 * whole application is just to visualize a given graph algorithm it is not
 * important to support any given graph. The provided example graphs fit this
 * restriction as they only contain six graphs
 * 
 * @author paulehler
 *
 */
public class GraphPanel extends JPanel {

	/**
	 * Autogenerated unique serial version identifier
	 * 
	 * @see Serializable#serialVersionUID
	 */
	private static final long serialVersionUID = -5620542123743722497L;

	// Vertex Properties
	private static final int VERTEX_DIAMETER = 80;
	private static final int VERTEX_RADIUS = VERTEX_DIAMETER / 2;

	private static final Color DEFAULT_VERTEX_FILL_COLOR = Color.WHITE;
	private static final Color DEFAULT_VERTEX_BORDER_COLOR = Color.BLACK;

	// Panel properties
	private static final Color COLOR_BACKGROUND = new Color(0xBFBFBF);

	private Graphics2D g2;

	private ArrayList<Point> points;

	private ArrayList<LabeledVertexComponent> vertexComponents;
	private Map<Vertex, LabeledVertexComponent> mapVertexToVertexComponents;

	private ArrayList<DirectedEdgeComponent> edgeComponents;

	private ArrayList<DirectedEdgeComponent> transposedEdgeComponents;

	private Map<String, Color> legend;

	private Graph graph;

	private boolean showTransposedEdges = false;

	/**
	 * Constructor of GraphPanel.
	 * 
	 * @param graph graph to be displayed
	 * @param gui parent gui
	 */
	public GraphPanel(Graph graph, MainGUI gui) {
		this.graph = graph;
		this.setPreferredSize(new Dimension(gui.getFrame().getWidth() / 2, gui.getFrame().getHeight()));

		setBackground(COLOR_BACKGROUND);

		points = new ArrayList<>();

		edgeComponents = new ArrayList<>();
		vertexComponents = new ArrayList<>();
		transposedEdgeComponents = new ArrayList<>();
		mapVertexToVertexComponents = new HashMap<>();

		calculateVertexCoordinates();

		int pointCounter = 0;
		for (Vertex vertex : graph.getVertices()) {
			LabeledVertexComponent vComponent = new LabeledVertexComponent(vertex.getLabel(), points.get(pointCounter),
					DEFAULT_VERTEX_FILL_COLOR, DEFAULT_VERTEX_BORDER_COLOR);
			mapVertexToVertexComponents.put(vertex, vComponent);
			vertexComponents.add(vComponent);
			pointCounter++;
		}

		for (DirectedEdge edge : graph.getEdges()) {
			edgeComponents.add(new DirectedEdgeComponent(mapVertexToVertexComponents.get(edge.getSource()),
					mapVertexToVertexComponents.get(edge.getTarget())));
		}

		for (DirectedEdgeComponent edge : edgeComponents) {
			transposedEdgeComponents.add(new DirectedEdgeComponent(edge.getTargetVertex(), edge.getSourceVertex()));
		}
	}

	
	@Override
	protected void paintComponent(Graphics g) {
		if (graph != null) {
			super.paintComponent(g);
			g2 = (Graphics2D) g;

			// Set font
			Font currentFont = g2.getFont();
			Font newFont = currentFont.deriveFont(currentFont.getSize() * 1.8F);
			g2.setFont(newFont);
			g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

			calculateVertexCoordinates();

			// Draw edges
			if (!showTransposedEdges) {
				for (DirectedEdgeComponent directedEdgeComponent : edgeComponents) {
					directedEdgeComponent.drawComponent(g2, Color.BLACK, VERTEX_RADIUS);
				}
			} else {
				for (DirectedEdgeComponent directedEdgeComponent : transposedEdgeComponents) {
					directedEdgeComponent.drawComponent(g2, Color.BLACK, VERTEX_RADIUS);
				}
			}

			// Draw vertices
			for (LabeledVertexComponent vertexComponent : vertexComponents) {
				vertexComponent.drawComponent(g2, VERTEX_DIAMETER);
			}

			// Draw Legend
			drawLegend();

		}
	}

	/**
	 * Draw legend for better understanding of the different colors and their
	 * meanings.
	 */
	private void drawLegend() {
		if (legend != null) {
			// Set font properties
			Font currentFont = this.getFont();
			Font newFont = currentFont.deriveFont(currentFont.getSize() * 0.8F);
			// Get the FontMetrics to center text horizontally to circles
			FontMetrics metrics = g2.getFontMetrics(newFont);

			int circleDiameter = 15;
			int counter = circleDiameter * 2;
			int xCircle = circleDiameter;
			int xText = (int) (xCircle + (circleDiameter * 1.5));
			for (Map.Entry<String, Color> entry : legend.entrySet()) {
				
				int yText = (int) getSize().getHeight() - counter + ((circleDiameter - metrics.getHeight()) / 2)
						+ metrics.getAscent();

				// Draw the String
				g2.setColor(entry.getValue());
				g2.fillOval(xCircle, (int) getSize().getHeight() - counter, circleDiameter, circleDiameter);
				g2.setColor(Color.BLACK);
				g2.setFont(newFont);
				g2.drawString(entry.getKey(), xText, yText);

				counter = counter + (circleDiameter * 2);
			}
		}
	}

	/**
	 * Calculate the coordinates for all vertices of the graph.
	 * <p>
	 * At the present time the visualization of the graph only works for six
	 * vertices. As long as no intelligent layouting is implemented the vertices
	 * will get placed in a hexagonal shape to guarantee a non competing placing.
	 * That way the drawn displayed graph will always look pretty without any
	 * interfering graph positions.
	 * 
	 * <pre>
	 * The points are calculated by dividing the panels width by 5 and the height by 4. This will result in a grid.
	 * The points get placed on this grid as follows:
	 * . . . . . .	
	 * . . o o . .	height / 4
	 * . o . . o .	height / 2
	 * . . o o . .	height / 4 * 3
	 * . . . . . .	
	 *   | | | |-> width / 5 * 4
	 *   | | |-> width / 5 * 3
	 *   | |-> width / 5 * 2
	 *   |-> width / 5
	 * </pre>
	 * 
	 */
	private void calculateVertexCoordinates() {
		points.clear();
		points.add(new Point((this.getWidth() / 5) - VERTEX_RADIUS, (this.getHeight() / 2) - VERTEX_RADIUS));
		points.add(new Point((this.getWidth() / 5 * 2) - VERTEX_RADIUS, (this.getHeight() / 4) - VERTEX_RADIUS));
		points.add(new Point((this.getWidth() / 5 * 3) - VERTEX_RADIUS, (this.getHeight() / 4) - VERTEX_RADIUS));
		points.add(new Point((this.getWidth() / 5 * 4) - VERTEX_RADIUS, (this.getHeight() / 2) - VERTEX_RADIUS));
		points.add(new Point((this.getWidth() / 5 * 3) - VERTEX_RADIUS, (this.getHeight() / 4 * 3) - VERTEX_RADIUS));
		points.add(new Point((this.getWidth() / 5 * 2) - VERTEX_RADIUS, (this.getHeight() / 4 * 3) - VERTEX_RADIUS));

		for (int i = 0; i < vertexComponents.size(); i++) {
			vertexComponents.get(i).setCoordinates(points.get(i));
		}

	}

	/**
	 * Set color of specific vertex with given color.
	 * 
	 * @param vertex vertex that should be modified
	 * @param color  color the vertex should be drawn
	 */
	public void setVertexColor(Vertex vertex, Color color) {
		LabeledVertexComponent vertexComp = getComponentFromVertex(vertex);
		vertexComp.setColor(color, color.darker());
	}

	/**
	 * Set border color of specific vertex with given color.
	 * 
	 * @param vertex
	 * @param borderColor
	 */
	public void setVertexBorderColor(Vertex vertex, Color borderColor) {
		LabeledVertexComponent vertexComp = getComponentFromVertex(vertex);
		vertexComp.setBorderColor(borderColor);
	}

	/**
	 * Get the vertex component of the corresponding vertex.
	 * 
	 * @param vertex
	 * @return component related to the specific vertex
	 */
	private LabeledVertexComponent getComponentFromVertex(Vertex vertex) {
		return mapVertexToVertexComponents.get(vertex);
	}

	/**
	 * Set the legend of the GraphPanel to show what the colors of vertices mean.
	 * 
	 * @param mapDisplayNameToColor map that matches colors with the name to display
	 */
	public void setLegend(Map<String, Color> mapDisplayNameToColor) {
		legend = mapDisplayNameToColor;
	}

	/**
	 * Decides if the given graph or transposed graph should be displayed.
	 * <p>
	 * If true, the transposed graph will be drawn at next invoke of
	 * {@link #paintComponent(Graphics)} method. Else the original graph is drawn.
	 * 
	 * @param showTransposedEdges boolean to decide if transposed graph should be
	 *                            displayed
	 */
	public void shouldDrawTransposed(boolean showTransposedEdges) {
		this.showTransposedEdges = showTransposedEdges;
	}
	
	/**
	 * Change edge orientation of all components in {@link #edgeComponents}
	 * 
	 * @deprecated ("better" solution has been found to display transposed graph at {@link #shouldDrawTransposed()})
	 * @see {@link #shouldDrawTransposed()}
	 */
	@Deprecated(forRemoval=true)
	public void reverseEdges() {
		ArrayList<DirectedEdgeComponent> tmpEdges = new ArrayList<>();
		for (DirectedEdgeComponent edge : edgeComponents) {
			tmpEdges.add(new DirectedEdgeComponent(edge.getTargetVertex(), edge.getSourceVertex()));
		}
		edgeComponents = tmpEdges;

	}

}
