package graphanalyzer.view.components;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.GeneralPath;
import java.io.Serializable;

/**
 * This class represents a directed edge component to draw in a graph.
 * 
 * 
 * @author paulehler
 *
 */
public class DirectedEdgeComponent implements Serializable {

	/**
	 * Autogenerated unique serial version identifier
	 * 
	 * @see Serializable#serialVersionUID
	 */
	private static final long serialVersionUID = 1200993879839953540L;

	/**
	 * Source vertex the edge should be drawn from.
	 */
	private VertexComponent sourceVertex;

	/**
	 * Target vertex the edge should be drawn to.
	 */
	private VertexComponent targetVertex;

	/**
	 * 
	 */
	private Color fillColor;

	/**
	 * 
	 * @param source
	 * @param target
	 */
	public DirectedEdgeComponent(VertexComponent source, VertexComponent target) {
		this.sourceVertex = source;
		this.targetVertex = target;
	}

	/**
	 * Draws the directed edge based on the vertex radius.
	 * <p>
	 * The radius is needed to calculate the right coordinates of the arrow head.
	 * The calculation is just simple math, sorry for the confusing code...I am no
	 * math guy.
	 * 
	 * @param graphics     graphics
	 * @param color        the stroke color of the edge
	 * @param vertexRadius the vertex radius
	 */
	public void drawComponent(Graphics2D graphics, Color color, int vertexRadius) {

		// Calculate middle of vertex as start and end coordinates
		double sourceX = sourceVertex.getCoordinates().getX() + vertexRadius;
		double sourceY = sourceVertex.getCoordinates().getY() + vertexRadius;

		double targetX = targetVertex.getCoordinates().getX() + vertexRadius;
		double targetY = targetVertex.getCoordinates().getY() + vertexRadius;

		double deltax = sourceX - targetX;
		double deltay = sourceY - targetY;

		double angle;
		if (deltax == 0) {
			angle = Math.PI / 2.0; // cos(pi/2) = 0
		} else if (deltax > 0) {
			angle = Math.atan(deltay / deltax) + Math.PI;
		} else {
			angle = Math.atan(deltay / deltax);
		}

		graphics.setColor(color);

		GeneralPath arrowHead = new GeneralPath();

		if (deltay > 0 && deltax == 0) {
			graphics.drawLine((int) ((sourceX) + Math.cos(angle) * vertexRadius),
					(int) ((sourceY) - Math.sin(angle) * vertexRadius),
					(int) ((targetX) - Math.cos(angle) * vertexRadius),
					(int) ((targetY) + Math.sin(angle) * vertexRadius));

			arrowHead.moveTo((targetX) + Math.cos(angle) * (vertexRadius),
					(targetY) + Math.sin(angle) * (vertexRadius)); // tip of arrow
			arrowHead.lineTo((targetX) + Math.cos(angle + Math.PI / 18.0d) * 55,
					(targetY) + Math.sin(angle + Math.PI / 18.0d) * 55); // right
			arrowHead.lineTo((targetX) + Math.cos(angle - Math.PI / 18.0d) * 55,
					(targetY) + Math.sin(angle - Math.PI / 18.0d) * 55); // left

		} else {
			graphics.drawLine((int) ((sourceX) + Math.cos(angle) * vertexRadius),
					(int) ((sourceY) + Math.sin(angle) * vertexRadius),
					(int) ((targetX) - Math.cos(angle) * vertexRadius),
					(int) ((targetY) - Math.sin(angle) * vertexRadius));

			arrowHead.moveTo((targetX) - Math.cos(angle) * (vertexRadius),
					(targetY) - Math.sin(angle) * (vertexRadius)); // tip of arrow
			arrowHead.lineTo((targetX) - Math.cos(angle + Math.PI / 18.0d) * 55,
					(targetY) - Math.sin(angle + Math.PI / 18.0d) * 55); // right
			arrowHead.lineTo((targetX) - Math.cos(angle - Math.PI / 18.0d) * 55,
					(targetY) - Math.sin(angle - Math.PI / 18.0d) * 55); // left

		}

		arrowHead.closePath();
		graphics.fill(arrowHead);

	}

	/**
	 * @return source vertex component
	 */
	public VertexComponent getSourceVertex() {
		return sourceVertex;
	}

	/**
	 * 
	 * @return target vertex component
	 */
	public VertexComponent getTargetVertex() {
		return targetVertex;
	}

}
